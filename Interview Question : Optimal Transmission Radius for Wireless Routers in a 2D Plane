Given a 2D coordinate plane with n n n routers placed at distinct coordinates, the ith i^{th} ith router is at the coordinates (x,y)=(xCord[i],yCord[i])(x, y) = (xCord[i], yCord[i])(x,y)=(xCord[i],yCord[i]).
Implement a function to find the smallest integer transmission radius so that every router is within range of at least one other router.
The function getMinimumRadius takes two inputs:

int xCord[n]: the x coordinates of the routers
int yCord[n]: the y coordinates of the routers

The function should return the smallest integer transmission radius so that every router is within range of at least one other router. All routers share the same transmission radius.
Note:

A router, R2 R_2 R2​, at position (x2,y2)(x_2, y_2)(x2​,y2​), is within range of another router, R1 R_1 R1​, at position (x1,y1)(x_1, y_1)(x1​,y1​), if the Euclidean distance between them is less than or equal to r1 r_1 r1​, the transmission radius of router 1.
The Euclidean distance between two points (x1,y1)(x_1, y_1)(x1​,y1​) and (x2,y2)(x_2, y_2)(x2​,y2​) in a 2D plane is defined as the straight-line distance between them. It is calculated using the formula: (x2−x1)2+(y2−y1)2\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2}(x2​−x1​)2+(y2​−y1​)2​

Example
n=2 n = 2 n=2
xCord=[1,1] xCord = [1, 1] xCord=[1,1]
yCord=[2,5] yCord = [2, 5] yCord=[2,5]

We have two points, p1 p_1 p1​ and p2 p_2 p2​ as points (1,2) and (1,5), respectively. The Euclidean distance between the two points is 3 units. Hence, the optimal transmission radius is 3.
Constraints

2≤n≤2000 2 \leq n \leq 2000 2≤n≤2000
0≤xCord[i]<107 0 \leq xCord[i] < 10^7 0≤xCord[i]<107
0≤yCord[i]<107 0 \leq yCord[i] < 10^7 0≤yCord[i]<107

Input Format for Custom Testing
The first line contains an integer n n n, the size of the array xCord xCord xCord.
Each of the next n n n lines contains an integer xCord[i] xCord[i] xCord[i].
The next line contains an integer n n n, the size of the array yCord yCord yCord.
Each of the next n n n lines contains an integer yCord[i] yCord[i] yCord[i].

Sample Case 0
Sample Input 0
3
0
3
6
3
0
0
0

Sample Output 0
3

Explanation
Distance of router 1 from the other 2 routers:
Distance from router 2: (0−3)2+(0−0)2=3\sqrt{(0-3)^2 + (0-0)^2} = 3(0−3)2+(0−0)2​=3
Distance from router 3: (0−6)2+(0−0)2=6\sqrt{(0-6)^2 + (0-0)^2} = 6(0−6)2+(0−0)2​=6
The minimum radius for router 1, R1 R_1 R1​, is 3 units.
Similarly, the minimum radius for the other two routers are:
R2:3 R_2: 3 R2​:3 Units
R3:3 R_3: 3 R3​:3 Units
The minimum radius for all the routers is 3 units.

Sample Case 1
Sample Input 1
3
0
4
0
3
0
0
3

Sample Output 1
4

Explanation
The minimum radius for all three routers are:
R1:3 R_1: 3 R1​:3 Units
R2:4 R_2: 4 R2​:4 Units
R3:3 R_3: 3 R3​:3 Units
The minimum radius for all the routers is 4 units.




Solution : 
from collections import deque, defaultdict

def recoverNetwork(network_nodes, network_from, network_to, company):
    graph = defaultdict(list)
    for frm, to in zip(network_from, network_to):
        graph[frm].append(to)
        graph[to].append(frm)

    visited = set()
    queue = deque([company])
    visited.add(company)
    recovery_order = []

    while queue:
        current = queue.popleft()
        for neighbor in sorted(graph[current]):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
                recovery_order.append(neighbor)

    return recovery_order

# Example usage
network_nodes = 4
network_from = [1, 2, 2]
network_to = [2, 3, 4]
company = 1
print(recoverNetwork(network_nodes, network_from, network_to, company))  # Output: [2, 3, 4]

